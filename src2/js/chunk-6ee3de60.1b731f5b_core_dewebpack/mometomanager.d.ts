/**
 * Module: MometoManager
 * Manages undo/redo history using diff-based state management
 */

import { DiffMatchPatch } from './diff-match-patch';

/**
 * Serializable view interface that can be converted to/from string representation
 */
interface ISerializableView {
  /**
   * Converts the view's current state to a string representation
   * @returns Serialized state string
   */
  serialize(): string;

  /**
   * Restores the view's state from a string representation
   * @param state - Serialized state string to restore
   */
  deserialize(state: string): void;

  /**
   * Refreshes the view's display after state changes
   */
  refresh(): void;
}

/**
 * Patch object representing a diff between two states
 * Generated by diff-match-patch library
 */
type Patch = any; // Actual type from diff-match-patch library

/**
 * Manages memento pattern implementation for undo/redo functionality
 * Uses diff-match-patch library for efficient state diffing
 */
export class MometoManager {
  /**
   * The view being managed
   */
  private readonly view: ISerializableView;

  /**
   * Current position in the history stack
   * -1 indicates no history
   */
  private historyPointer: number;

  /**
   * Last recorded state checkpoint
   */
  private lastPoint: string;

  /**
   * Stack of diffs representing history
   */
  private diffs: Patch[];

  /**
   * Original checkpoint for dirty state tracking
   * Empty string indicates no original checkpoint set
   */
  private oriPoint: string;

  /**
   * Diff-match-patch instance for computing diffs
   */
  private readonly dmp: DiffMatchPatch;

  /**
   * Creates a new MometoManager instance
   * @param view - The serializable view to manage
   */
  constructor(view: ISerializableView) {
    this.view = view;
    this.historyPointer = -1;
    this.lastPoint = '';
    this.diffs = [];
    this.oriPoint = '';
    this.dmp = new DiffMatchPatch();
  }

  /**
   * Indicates whether the current state differs from the original checkpoint
   * @returns true if state has been modified, false otherwise
   */
  get isDirty(): boolean {
    return this.oriPoint !== ''
      ? this.oriPoint !== this.view.serialize()
      : this.diffs.length > 0;
  }

  /**
   * Undoes the last change
   * @param popLast - If true, removes the last diff from history (default: false)
   */
  undo(popLast: boolean = false): void {
    if (this.historyPointer < 0) {
      return;
    }

    const diff = this.diffs[this.historyPointer];
    
    if (popLast) {
      this.diffs.pop();
    }

    this.lastPoint = this.applyDiff(this.lastPoint, diff);
    this.view.deserialize(this.lastPoint);
    this.view.refresh();
    this.historyPointer--;
  }

  /**
   * Recovers the last recorded checkpoint state
   */
  recoverLast(): void {
    this.view.deserialize(this.lastPoint);
    this.view.refresh();
  }

  /**
   * Redoes the previously undone change
   */
  redo(): void {
    if (
      this.historyPointer === this.diffs.length - 1 ||
      this.diffs.length === 0
    ) {
      return;
    }

    this.historyPointer++;
    const diff = this.diffs[this.historyPointer];
    this.lastPoint = this.applyDiffInv(this.lastPoint, diff);
    this.view.deserialize(this.lastPoint);
    this.view.refresh();
  }

  /**
   * Creates a checkpoint of the current state
   * @param setOrigin - If true, marks this checkpoint as the original (clean) state
   */
  checkPoint(setOrigin: boolean = false): void {
    try {
      this._checkPoint();
      if (setOrigin) {
        this.oriPoint = this.lastPoint;
      }
    } catch (error) {
      const errorMessage = String(error).split(/\r?\n/)[0];
      console.warn(errorMessage);
    }
  }

  /**
   * Internal checkpoint implementation
   * @private
   */
  private _checkPoint(): void {
    const currentState = this.view.serialize();

    if (currentState === this.lastPoint) {
      return;
    }

    const diff = this.getDiff(currentState, this.lastPoint);

    // Truncate any forward history if not at the end
    if (this.historyPointer !== this.diffs.length - 1) {
      this.diffs.splice(
        this.historyPointer + 1,
        this.diffs.length - this.historyPointer + 1
      );
    }

    this.diffs.push(diff);
    this.historyPointer = this.diffs.length - 1;
    this.lastPoint = currentState;
  }

  /**
   * Clears all history and resets to initial state
   */
  clean(): void {
    this.historyPointer = -1;
    this.lastPoint = '';
    this.diffs = [];
    this.oriPoint = '';
  }

  /**
   * Computes the diff between two states
   * @param newState - The new state
   * @param oldState - The old state
   * @returns Patch object representing the diff
   * @private
   */
  private getDiff(newState: string, oldState: string): Patch {
    const diffs = this.dmp.diff_main(newState, oldState, true);

    if (diffs.length > 2) {
      this.dmp.diff_cleanupSemantic(diffs);
    }

    return this.dmp.patch_make(newState, oldState, diffs);
  }

  /**
   * Applies a diff patch to a state
   * @param state - The state to apply the patch to
   * @param patch - The patch to apply
   * @returns The resulting state after applying the patch
   * @private
   */
  private applyDiff(state: string, patch: Patch): string {
    return this.dmp.patch_apply(patch, state)[0];
  }

  /**
   * Applies a diff patch in reverse
   * @param state - The state to apply the inverse patch to
   * @param patch - The patch to apply in reverse
   * @returns The resulting state after applying the inverse patch
   * @private
   */
  private applyDiffInv(state: string, patch: Patch): string {
    this.reversePatch(patch);
    const result = this.applyDiff(state, patch.slice().reverse());
    this.reversePatch(patch);
    return result;
  }

  /**
   * Reverses a patch by inverting all diff operations
   * @param patch - The patch to reverse (modified in place)
   * @private
   */
  private reversePatch(patch: Patch): void {
    patch.forEach((patchItem: any) => {
      patchItem.diffs.forEach((diff: [number, string]) => {
        diff[0] *= -1;
      });
    });
  }
}