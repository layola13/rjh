# dist6 2Då‡ ä½•å†…æ ¸ä¸çº¦æŸç³»ç»Ÿæ·±åº¦åˆ†æ

## æ‰§è¡Œæ‘˜è¦

dist6å®ç°äº†å®Œæ•´çš„**2Då‚æ•°åŒ–å‡ ä½•å†…æ ¸**,åŒ…å«è‡ªå®šä¹‰çš„2Då‡ ä½•å›¾å…ƒã€çº¦æŸæ±‚è§£ç³»ç»Ÿå’Œè‰å›¾ç¼–è¾‘å¼•æ“ã€‚

**æ ¸å¿ƒç‰¹ç‚¹**: è‡ªå®šä¹‰å®ç° + å‚æ•°åŒ–çº¦æŸé©±åŠ¨

---

## ä¸€ã€2Då‡ ä½•å†…æ ¸æ¶æ„

### 1.1 æ ¸å¿ƒç»„ä»¶å±‚æ¬¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   åº”ç”¨å±‚ (Sketchç¼–è¾‘å™¨/å¢™ä½“ç»˜åˆ¶/å¼€å­”)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   çº¦æŸæ±‚è§£å±‚                                 â”‚
â”‚   - EquationConstraint (æ–¹ç¨‹çº¦æŸ)           â”‚
â”‚   - PositionConstraint (ä½ç½®çº¦æŸ)           â”‚
â”‚   - ConstraintManager (çº¦æŸç®¡ç†å™¨)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   2Då‡ ä½•å›¾å…ƒå±‚                               â”‚
â”‚   - Curve2d (åŸºç±»)                          â”‚
â”‚   - Line2d (ç›´çº¿)                           â”‚
â”‚   - Arc2d (åœ†å¼§)                            â”‚
â”‚   - Circle2d (åœ†)                           â”‚
â”‚   - PolyCurve2d (å¤åˆæ›²çº¿)                  â”‚
â”‚   - Polygon2d (å¤šè¾¹å½¢)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   æ•°å­¦åŸºç¡€å±‚                                 â”‚
â”‚   - Point2d (äºŒç»´ç‚¹)                        â”‚
â”‚   - Vector2 (äºŒç»´å‘é‡)                      â”‚
â”‚   - MathAlg (å‡ ä½•ç®—æ³•åº“)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ–‡ä»¶ç»„ç»‡

| ç±»åˆ« | æ ¸å¿ƒæ–‡ä»¶ | æ¨¡å—ID | è¯´æ˜ |
|------|---------|--------|------|
| **åŸºç¡€ç±»** | curve2d_io.js | 46088 | 2Dæ›²çº¿åŸºç±» |
| **å›¾å…ƒ** | line2d_io.js | 43297 | 2Dç›´çº¿ |
| | arc2d.js | 80534 | 2Dåœ†å¼§ |
| | circle2d.js | 99876, 51856 | 2Dåœ† |
| | polygon2d.js | 47816 | 2Då¤šè¾¹å½¢ |
| | polycurve2d.js | 99123 | å¤åˆæ›²çº¿ |
| **çº¦æŸ** | constraint.js | 84418, 48855 | çº¦æŸåŸºç±» |
| | positionconstraint.js | 47636 | ä½ç½®çº¦æŸ |
| | module_26429.js | 26429 | æ–¹ç¨‹çº¦æŸ |
| | constraintfactory.js | 99857 | çº¦æŸå·¥å‚ |
| | constrainthelper.js | 223024 | çº¦æŸè¾…åŠ©å™¨ |
| **é«˜çº§** | continuouscurve2d.js | 24194 | è¿ç»­æ›²çº¿ |
| | extraordinarycurve2d.js | 35656 | ç‰¹æ®Šæ›²çº¿ |
| | discretepolygon2d.js | 1081 | ç¦»æ•£å¤šè¾¹å½¢ |

---

## äºŒã€2Då‡ ä½•å›¾å…ƒç³»ç»Ÿ

### 2.1 Curve2d (2Dæ›²çº¿åŸºç±»)

```javascript
// æ–‡ä»¶: curve2d_io.js (46088)
class Curve2d extends Entity {
    __isbackground: boolean = false  // æ˜¯å¦ä¸ºèƒŒæ™¯æ›²çº¿
    
    // è®¿é—®å™¨
    get from(): Point2d      // èµ·ç‚¹
    get to(): Point2d        // ç»ˆç‚¹
    get direction(): Vector2 // æ–¹å‘å‘é‡
    get key(): string        // å”¯ä¸€æ ‡è¯†
    
    // æ ¸å¿ƒæ–¹æ³•
    toTHREECurve(): THREE.Curve           // è½¬æ¢ä¸ºTHREE.jsæ›²çº¿
    createSubCurve(from, to): Curve2d    // åˆ›å»ºå­æ›²çº¿
    isBackground(): boolean               // æ£€æŸ¥æ˜¯å¦ä¸ºèƒŒæ™¯
    
    // æ‹“æ‰‘æŸ¥è¯¢
    getOuterWires(): Wire[]               // è·å–å¤–ç¯
    getPolygons(): Set<Polygon>           // è·å–æ‰€å±å¤šè¾¹å½¢
    
    // éªŒè¯
    verify(): boolean {
        const parents = Object.values(this.parents)
            .filter(p => p instanceof Wire);
        
        if (parents.length < 1) {
            return false; // å¿…é¡»æœ‰çˆ¶çº§Wire
        }
        
        if (parents.length > 2) {
            console.warn(`Curve has ${parents.length} parents`);
        }
        
        return super.verify();
    }
    
    // åœ†å¼§ç¦»æ•£åŒ–
    getArcPoints(curve, options): Point2d[] {
        return HSCore.Util.Geometry.getArcPoints(curve, options);
    }
}
```

**è®¾è®¡ç‰¹ç‚¹**:
- âœ… Entityæ´¾ç”Ÿ,æ”¯æŒçˆ¶å­å…³ç³»ç®¡ç†
- âœ… æœ€å¤š2ä¸ªçˆ¶çº§Wire(æµå½¢è¾¹ç•Œ)
- âœ… èƒŒæ™¯æ›²çº¿æ ‡è®°(ç”¨äºè¾…åŠ©çº¿)
- âœ… THREE.jsé›†æˆ

---

### 2.2 Arc2d (2Dåœ†å¼§)

```javascript
// æ–‡ä»¶: arc2d.js (80534)
class Arc2d extends Curve2d {
    start: Point2d      // èµ·ç‚¹
    end: Point2d        // ç»ˆç‚¹
    center: Point2d     // åœ†å¿ƒ
    radius: number      // åŠå¾„
    clockwise: boolean  // é¡ºæ—¶é’ˆ/é€†æ—¶é’ˆ
    
    // åˆ›å»º
    static create(params: IArc2d): Arc2d {
        const arc = new Arc2d();
        arc.assign(params);
        return arc;
    }
    
    // èµ‹å€¼
    assign(params: IArc2d): void {
        this.start.assign(params.start);
        this.end.assign(params.end);
        this.center.assign(params.center);
        this.radius = params.radius;
        this.clockwise = params.clockwise;
    }
    
    // åºåˆ—åŒ–
    dump(): IArc2dDump {
        return {
            ln: [this.start.dump(), this.end.dump()],
            c: this.center.dump(),
            r: this.radius,
            cw: this.clockwise,
            gt: GeometryObjectType.Arc2d
        };
    }
    
    // ç¦»æ•£åŒ–
    getDiscretePoints(options = {}): Point2d[] {
        const threeCurve = this._toThreeCurve();
        return HSCore.Util.Geometry.getArcPoints(threeCurve, options)
            .map(p => ({ x: p.x, y: p.y }));
    }
    
    // è½¬æ¢ä¸ºTHREE.jsåœ†å¼§
    _toThreeCurve(): THREE.Arc {
        const center = GeLib.VectorUtils.toTHREEVector3(this.center);
        const start = GeLib.VectorUtils.toTHREEVector3(this.start);
        const end = GeLib.VectorUtils.toTHREEVector3(this.end);
        
        return GeLib.ArcUtils.createArcFromPoints(
            start, end, center, this.radius, this.clockwise
        );
    }
    
    // å‚æ•°åŒ–å–ç‚¹
    getPoint(t: number): Point2d {
        if (nearlyEquals(t, 0)) return this.start;
        if (nearlyEquals(t, 1)) return this.end;
        
        return this._toThreeCurve().getPoint(t);
    }
    
    // ç›¸ç­‰åˆ¤æ–­
    isSameCurve(other: Arc2d, tolerance = TOLERANCE): boolean {
        if (this === other) return true;
        if (this.getType() !== other.getType()) return false;
        
        // æ£€æŸ¥åœ†å¿ƒå’ŒåŠå¾„
        if (!isSamePoint(this.center, other.center, tolerance)) return false;
        if (!nearlyEquals(this.radius, other.radius, tolerance)) return false;
        
        // æ£€æŸ¥èµ·ç»ˆç‚¹(è€ƒè™‘æ–¹å‘)
        if (this.clockwise == other.clockwise) {
            if (!isSamePoint(this.start, other.start, tolerance) ||
                !isSamePoint(this.end, other.end, tolerance)) {
                return false;
            }
        } else {
            if (!isSamePoint(this.start, other.end, tolerance) ||
                !isSamePoint(this.end, other.start, tolerance)) {
                return false;
            }
        }
        
        return true;
    }
    
    // åˆ›å»ºå­åœ†å¼§
    createSubCurve(start: Point2d, end: Point2d): Arc2d {
        return Arc2d.create({
            center: this.center,
            radius: this.radius,
            start: start,
            end: end,
            clockwise: this.clockwise
        });
    }
    
    // ç‚¹åœ¨æ›²çº¿ä¸Šåˆ¤æ–­
    isPointOnCurve(point: Point2d, tolerance = TOLERANCE): boolean {
        const threePoint = GeLib.VectorUtils.toTHREEVector3(point);
        return isPointOnCurve(threePoint, this._toThreeCurve(), tolerance);
    }
    
    // æ°´å¹³çº¿ç›¸äº¤
    hLineIntersections(y: number): Point2d[] {
        const results = [];
        
        const hLine = GeLib.LineUtils.toTHREELine3(
            {x: 0, y: y},
            {x: 1, y: y}
        );
        
        const arc = this._toThreeCurve();
        const info = GeLib.CurveUtils.getIntersectionInfo(arc, hLine);
        
        if (!info) return results;
        
        for (let i = 0; i < info.intersects.length; i++) {
            const point = info.intersects[i];
            const param = info.thisParams[i];
            
            // åªä¿ç•™å‚æ•°åœ¨[0,1]èŒƒå›´å†…çš„äº¤ç‚¹
            if (numberInRange(param, 0, 1, true) && point) {
                results.push(point);
            }
        }
        
        return results;
    }
}
```

**ç‰¹æ€§**:
- âœ… å®Œæ•´çš„åœ†å¼§è¡¨ç¤º(ä¸­å¿ƒ+åŠå¾„+èµ·ç»ˆç‚¹+æ–¹å‘)
- âœ… å‚æ•°åŒ–é‡‡æ ·
- âœ… æ°´å¹³çº¿ç›¸äº¤æ£€æµ‹(ç”¨äºç‚¹åœ¨å¤šè¾¹å½¢å†…åˆ¤æ–­)
- âœ… GeLibåº“é›†æˆ

---

### 2.3 Polygon2d (2Då¤šè¾¹å½¢)

```javascript
// æ–‡ä»¶: polygon2d.js (47816)
class Polygon2d {
    outer: PolyCurve2d      // å¤–è¾¹ç•Œ
    holes: PolyCurve2d[]    // å†…å­”æ•°ç»„
    
    constructor() {
        this.outer = new PolyCurve2d();
        this.holes = [];
    }
    
    // åˆ›å»º
    static create(data: IPolygon2dDump): Polygon2d {
        const polygon = new Polygon2d();
        polygon.load(data);
        return polygon;
    }
    
    // èµ‹å€¼
    assign(other: Polygon2d): void {
        this.outer.assign(other.outer);
        
        resizeArray(this.holes, other.holes.length, 
            () => new PolyCurve2d());
        
        for (let i = 0; i < this.holes.length; i++) {
            this.holes[i].assign(other.holes[i]);
        }
    }
    
    // åºåˆ—åŒ–
    dump(): IPolygon2dDump {
        return {
            outer: this.outer.dump(),
            holes: this.holes.map(h => h.dump())
        };
    }
    
    // å…‹éš†
    clone(): Polygon2d {
        const polygon = new Polygon2d();
        polygon.load(this.dump());
        return polygon;
    }
    
    // ä»ç¦»æ•£å¤šè¾¹å½¢è®¾ç½®
    setFromDiscretePolygon(discrete: DiscretePolygon): void {
        this.outer.setFromPoints(discrete.outer);
        
        resizeArray(this.holes, discrete.holes.length,
            () => new PolyCurve2d());
        
        for (let i = 0; i < this.holes.length; i++) {
            this.holes[i].setFromPoints(discrete.holes[i]);
        }
    }
    
    // è½¬æ¢ä¸ºç¦»æ•£å¤šè¾¹å½¢
    toDiscretePolygon(options = {}): DiscretePolygon {
        return {
            outer: this.outer.getDiscretePoints(options),
            holes: this.holes.map(h => h.getDiscretePoints(options))
        };
    }
    
    // ç‚¹åœ¨å¤šè¾¹å½¢å†…åˆ¤æ–­(å°„çº¿æ³•)
    isPointInside(
        point: Point2d, 
        includeOnOutline: boolean = true,
        tolerance: number = TOLERANCE
    ): boolean {
        // 1. ç‚¹åœ¨è¾¹ç•Œä¸Š
        if (includeOnOutline && this.isPointOnOutline(point, tolerance)) {
            return true;
        }
        
        // 2. å°„çº¿æ³•:æ”¶é›†æ‰€æœ‰ä¸æ°´å¹³å°„çº¿çš„äº¤ç‚¹
        const intersections = [];
        
        for (const polycurve of [this.outer, ...this.holes]) {
            for (const curve of polycurve.curves) {
                const points = curve.hLineIntersections(point.y);
                intersections.xPushCollection(points);
            }
        }
        
        // 3. ç»Ÿè®¡äº¤ç‚¹æ•°
        let inside = false;
        for (const intersection of intersections) {
            if (intersection.x > point.x) {
                inside = !inside;
            }
        }
        
        return inside;
    }
    
    // ç‚¹åœ¨è½®å»“ä¸Šåˆ¤æ–­
    isPointOnOutline(
        point: Point2d,
        tolerance: number = TOLERANCE
    ): boolean {
        for (const polycurve of [this.outer, ...this.holes]) {
            for (const curve of polycurve.curves) {
                if (curve.isPointOnCurve(point, tolerance)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    // å¤šè¾¹å½¢ç›¸ç­‰åˆ¤æ–­
    isSamePolygon2d(
        other: Polygon2d,
        tolerance: number = TOLERANCE
    ): boolean {
        if (this === other) return true;
        
        // æ£€æŸ¥å¤–è¾¹ç•Œ
        if (!this.outer.isSamePolyCurve(other.outer, tolerance)) {
            return false;
        }
        
        // æ£€æŸ¥å†…å­”
        return isSameArray(
            this.holes,
            other.holes,
            false,
            (a, b) => a.isSamePolyCurve(b, tolerance)
        );
    }
    
    // æ‰¹é‡æ“ä½œ
    static assignArray(target: Polygon2d[], source: Polygon2d[]): void {
        resizeArray(target, source.length, () => new Polygon2d());
        for (let i = 0; i < target.length; i++) {
            target[i].assign(source[i]);
        }
    }
    
    static loadArray(target: Polygon2d[], 
source: Polygon2d[]): void {
        resizeArray(target, source.length, () => new Polygon2d());
        for (let i = 0; i < target.length; i++) {
            target[i].load(source[i]);
        }
    }
}
```

**ç‰¹æ€§**:
- âœ… æ”¯æŒå¸¦å­”å¤šè¾¹å½¢
- âœ… ç‚¹åœ¨å¤šè¾¹å½¢å†…åˆ¤æ–­(å°„çº¿æ³•)
- âœ… ä¸ç¦»æ•£å¤šè¾¹å½¢äº’è½¬
- âœ… ç²¾ç¡®ç›¸ç­‰åˆ¤æ–­

---

## ä¸‰ã€çº¦æŸæ±‚è§£ç³»ç»Ÿ

### 3.1 çº¦æŸç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     ConstraintManager                â”‚
â”‚     (çº¦æŸç®¡ç†å™¨)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   State    â”‚  â”‚  Constraint    â”‚  â”‚
â”‚  â”‚   (çŠ¶æ€)   â”‚  â”‚  (çº¦æŸ)        â”‚  â”‚
â”‚  â”‚            â”‚  â”‚                â”‚  â”‚
â”‚  â”‚ - value    â”‚â—„â”€â”¤ - inputs[]    â”‚  â”‚
â”‚  â”‚ - localId  â”‚  â”‚ - outputs[]   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚        â–²                  â”‚           â”‚
â”‚        â”‚                  â”‚           â”‚
â”‚        â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”     â”‚
â”‚        â”‚    â”‚ EquationConstr   â”‚     â”‚
â”‚        â”‚    â”‚ (æ–¹ç¨‹çº¦æŸ)       â”‚     â”‚
â”‚        â”‚    â”‚ - equation: str  â”‚     â”‚
â”‚        â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚        â”‚                              â”‚
â”‚        â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚        â””â”€â”€â”€â”€â”¤ PositionConstr  â”‚      â”‚
â”‚             â”‚ (ä½ç½®çº¦æŸ)      â”‚      â”‚
â”‚             â”‚ - computeChain  â”‚      â”‚
â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 Constraint (çº¦æŸåŸºç±»)

```javascript
// æ–‡ä»¶: constraint.js (48855)
class Constraint extends Entity {
    localId: string          // æœ¬åœ°ID
    type: string             // çº¦æŸç±»å‹
    inputs: {id: State}      // è¾“å…¥çŠ¶æ€é›†åˆ
    outputs: {id: State}     // è¾“å‡ºçŠ¶æ€é›†åˆ
    
    constructor(id = "") {
        super(id);
        this.inputs = {};
        this.outputs = {};
    }
    
    // åˆå§‹åŒ–
    init(data, stateMap): void {
        this.localId = data.localId;
        this.type = data.type;
        // å­ç±»å®ç°å…·ä½“åˆå§‹åŒ–é€»è¾‘
    }
    
    // è®¡ç®—(ç”±å­ç±»å®ç°)
    compute(): void {
        // åŸºç±»è®°å½•è®¡ç®—
    }
    
    // åºåˆ—åŒ–
    dump(options = {}): any[] {
        const dump = {
            id: this.id,
            localId: this.localId,
            type: this.type,
            inputs: Object.values(this.inputs).map(s => s.id),
            outputs: Object.values(this.outputs).map(s => s.id),
            Class: this.Class
        };
        
        if (options.constraintsData) {
            options.constraintsData.set(this.id, dump);
        }
        
        return [dump];
    }
    
    // ååºåˆ—åŒ–
    static loadFromDump(data, options): Constraint {
        let id = data.id;
        
        if (options.constraintIdGenerator) {
            id = options.constraintIdGenerator.generate(id);
        }
        
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        if (id && options.constraints) {
            const existing = options.constraints[id];
            if (existing) return existing;
        }
        
        // åˆ›å»ºæ–°å®ä¾‹
        const ConstraintClass = this.getClass(data.l || data.Class);
        if (!ConstraintClass) return undefined;
        
        const constraint = new ConstraintClass(id);
        
        if (options.constraints) {
            options.constraints[constraint.id] = constraint;
        }
        
        constraint.load(data, options);
        
        return constraint;
    }
    
    // éªŒè¯
    verify(): boolean {
        // æ£€æŸ¥è¾“å…¥è¾“å‡ºçŠ¶æ€
        for (const state of Object.values(this.inputs)) {
            if (!state.verify()) return false;
        }
        
        for (const state of Object.values(this.outputs)) {
            if (!state.verify()) return false;
        }
        
        return true;
    }
    
    // æ³¨å†Œçº¦æŸç±»
    static registerClass(className: string, ConstraintClass): void {
        // æ³¨å†Œåˆ°å…¨å±€ç±»æ³¨å†Œè¡¨
        this._classRegistry[className] = ConstraintClass;
    }
    
    static getClass(className: string): typeof Constraint {
        return this._classRegistry[className];
    }
}
```

---

### 3.3 EquationConstraint (æ–¹ç¨‹çº¦æŸ)

```javascript
// æ–‡ä»¶: module_26429.js (26429)
class EquationConstraint extends Constraint {
    equation: string = ""                    // æ–¹ç¨‹å­—ç¬¦ä¸²
    isAssignmentExpression: boolean = false  // æ˜¯å¦ä¸ºèµ‹å€¼è¡¨è¾¾å¼
    
    constructor(id = "") {
        super(id);
        this.Class = "HSCore.Constraint.EquationConstraint";
        this.logger = log.logger("EquationConstraint");
    }
    
    // åˆå§‹åŒ–
    init(data, stateMap): void {
        super.init(data, stateMap);
        this.localId = data.localId;
        this.type = data.type;
        this.equation = data.equation;
        this.refresh(stateMap);
    }
    
    // è§£ææ–¹ç¨‹å¹¶å»ºç«‹ä¾èµ–å…³ç³»
    refresh(stateMap): void {
        let ast, tokens;
        
        try {
            // ä½¿ç”¨Esprimaè§£æJavaScriptè¡¨è¾¾å¼
            ast = Esprima.parse(this.equation);
            tokens = Esprima.tokenize(this.equation);
        } catch (error) {
            if (error instanceof Error) {
                this.logerror(error);
            }
            return;
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºèµ‹å€¼è¡¨è¾¾å¼
        if (ast.body.length !== 1) return;
        
        const expression = ast.body[0].expression;
        this.isAssignmentExpression = 
            expression.type === "AssignmentExpression";
        
        if (!this.isAssignmentExpression) return;
        
        // æå–å‡½æ•°è°ƒç”¨(æ’é™¤)
        const functionCalls = [];
        extractFunctionCalls(ast, functionCalls);
        
        // æå–æ‰€æœ‰æ ‡è¯†ç¬¦(çŠ¶æ€å˜é‡)
        const identifiers = [];
        tokens.forEach(token => {
            if (token.type === "Identifier" &&
                !functionCalls.includes(token.value)) {
                identifiers.push(token.value);
            }
        });
        
        // éªŒè¯æ‰€æœ‰æ ‡è¯†ç¬¦åœ¨stateMapä¸­å­˜åœ¨
        let valid = true;
        identifiers.forEach(id => {
            if (stateMap[id] === undefined) {
                valid = false;
                this.logerror(`Invalid equation: ${this.equation}`);
            }
        });
        
        if (!valid) return;
        
        // ç¬¬ä¸€ä¸ªæ ‡è¯†ç¬¦ä¸ºè¾“å‡º,å…¶ä½™ä¸ºè¾“å…¥
        if (identifiers.length > 0) {
            const outputId = identifiers[0];
            this.outputs[stateMap[outputId].id] = stateMap[outputId];
            
            for (let i = 1; i < identifiers.length; i++) {
                const inputId = identifiers[i];
                this.inputs[stateMap[inputId].id] = stateMap[inputId];
            }
        }
    }
    
    // è®¡ç®—çº¦æŸ
    compute(): void {
        super.compute();
        
        if (!this.isAssignmentExpression) return;
        
        // 1. æ„å»ºå˜é‡å£°æ˜ä»£ç 
        let declares = "";
        Object.values(this.inputs).forEach(state => {
            declares += `let ${state.localId} = ${state.value};`;
        });
        
        // 2. è·å–è¾“å‡ºå˜é‡å
        let outputName = "";
        if (Object.values(this.outputs).length > 0) {
            outputName = Object.values(this.outputs)[0].localId;
        }
        
        // 3. æ‰§è¡Œæ–¹ç¨‹
        const code = `
            ${declares}
            let ${this.equation};
            ${outputName};
        `;
        
        const result = eval(code);
        
        // 4. æ›´æ–°è¾“å‡ºçŠ¶æ€
        Object.values(this.outputs).forEach(state => {
            state.value = result;
        });
    }
    
    // åºåˆ—åŒ–
    dump(options = {}): any[] {
        const dumps = super.dump(options);
        dumps[0].equationVariables = {
            equation: this.equation,
            isAssignmentExpression: this.isAssignmentExpression
        };
        return dumps;
    }
    
    // ååºåˆ—åŒ–
    load(data, options = {}): void {
        super.load(data, options);
        this.equation = data.equationVariables.equation;
        this.isAssignmentExpression = 
            data.equationVariables.isAssignmentExpression;
    }
    
    // éªŒè¯
    verify(): boolean {
        return super.verify() && !!this.equation;
    }
}

// æ³¨å†Œçº¦æŸç±»
Constraint.registerClass(
    "HSCore.Constraint.EquationConstraint",
    EquationConstraint
);
Constraint.registerClass(
    "hsw.core.constraint.EquationConstraint",
    EquationConstraint
);
```

**æ–¹ç¨‹çº¦æŸç¤ºä¾‹**:

```javascript
// ç¤ºä¾‹1: ç®€å•èµ‹å€¼
equation: "width = 1000"
// è§£æç»“æœ:
// outputs: [width]
// inputs: []

// ç¤ºä¾‹2: ä¾èµ–è®¡ç®—
equation: "totalWidth = width + padding * 2"
// è§£æç»“æœ:
// outputs: [totalWidth]
// inputs: [width, padding]

// ç¤ºä¾‹3: å¤æ‚è¡¨è¾¾å¼
equation: "area = Math.PI * radius * radius"
// è§£æç»“æœ:
// outputs: [area]
// inputs: [radius]
// æ³¨æ„: Math.PIè¢«è¯†åˆ«ä¸ºå‡½æ•°è°ƒç”¨,ä¸ä½œä¸ºè¾“å…¥
```

---

### 3.4 PositionConstraint (ä½ç½®çº¦æŸ)

```javascript
// æ–‡ä»¶: positionconstraint.js (47636)
class PositionConstraint extends Constraint {
    computeChain: Array<{
        method: string,      // è®¡ç®—æ–¹æ³•
        states: State[]      // å‚ä¸çŠ¶æ€
    }> = []
    
    constructor(id = "") {
        super(id);
        this.Class = "HSCore.Constraint.PositionConstraint";
    }
    
    // åˆå§‹åŒ–
    init(data, stateMap): void {
        super.init(data, stateMap);
        this.localId = data.localId;
        this.type = data.type;
        
        // æ„å»ºè®¡ç®—é“¾
        data.inputs.forEach(input => {
            const states = (input.states || []).map(stateId => {
                const state = stateMap[stateId];
                this.inputs[state.id] = state;
                return state;
            });
            
            this.computeChain.push({
                method: input.method,
                states: states
            });
        });
        
        // è®¾ç½®è¾“å‡ºçŠ¶æ€
        if (data.output instanceof Array) {
            data.output.forEach(stateId => {
                const state = stateMap[stateId];
                this.outputs[state.id] = state;
            });
        } else {
            const state = stateMap[data.output];
            this.outputs[state.id] = state;
        }
    }
    
    // è®¡ç®—çº¦æŸ
    compute(): void {
        super.compute();
        
        let result = 0;
        
        // éå†è®¡ç®—é“¾
        this.computeChain.forEach(chain => {
            const values = chain.states.map(state => state.value);
            
            switch (chain.method) {
                case "add":
                    result += values.reduce((a, b) => a + b);
                    break;
                    
                case "sub":
                    result -= values.reduce((a, b) => a + b);
                    break;
                    
                case "mul":
                    result += values.reduce((a, b) => a * b);
                    break;
                    
                case "div":
                    result += values.reduce((a, b) => a / b);
                    break;
                    
                case "result_add":
                    result += values.reduce(a => a);
                    break;
                    
                case "result_sub":
                    result -= values.reduce(a => a);
                    break;
                    
                case "result_mul":
                    result *= values.reduce(a => a);
                    break;
                    
                case "result_div":
                    result /= values.reduce(a => a);
                    break;
                    
                case "nonnegative":
                    result = values.map(v => v < 0 ? 0 : v)[0];
                    break;
            }
        });
        
        // æ›´æ–°è¾“å‡ºçŠ¶æ€
        Object.values(this.outputs).forEach(state => {
            state.value = result;
        });
    }
    
    // åºåˆ—åŒ–
    dump(options = {}): any[] {
        const dumps = super.dump(options);
        
        const chainData = [];
        this.computeChain.forEach(chain => {
            chainData.push({
                method: chain.method,
                states: chain.states.map(s => s.id)
            });
        });
        
        dumps[0].computeChain = chainData;
        
        return dumps;
    }
    
    // ååºåˆ—åŒ–
    load(data, options = {}): void {
        super.load(data, options);
        
        this.computeChain = [];
        data.computeChain.forEach(chainData => {
            const states = chainData.states.map(stateId => {
                return options.states[stateId];
            });
            
            this.computeChain.push({
                method: chainData.method,
                states: states
            });
        });
    }
    
    // éªŒè¯
    verify(): boolean {
        return super.verify() && !!this.computeChain;
    }
}

// æ³¨å†Œçº¦æŸç±»
Constraint.registerClass(
    "HSCore.Constraint.PositionConstraint",
    PositionConstraint
);
Constraint.registerClass(
    "hsw.core.constraint.PositionConstraint",
    PositionConstraint
);
```

**ä½ç½®çº¦æŸç¤ºä¾‹**:

```javascript
// ç¤ºä¾‹1: ç®€å•åŠ æ³•
{
    type: "PositionConstraint",
    inputs: [{
        method: "add",
        states: ["width", "padding"]
    }],
    output: "totalWidth"
}
// è®¡ç®—: totalWidth = width + padding

// ç¤ºä¾‹2: é“¾å¼è®¡ç®—
{
    type: "PositionConstraint",
    inputs: [
        {
            method: "add",
            states: ["x", "offsetX"]
        },
        {
            method: "result_mul",
            states: ["scale"]
        }
    ],
    output: "finalX"
}
// è®¡ç®—: finalX = (x + offsetX) * scale

// ç¤ºä¾‹3: éè´Ÿçº¦æŸ
{
    type: "PositionConstraint",
    inputs: [{
        method: "nonnegative",
        states: ["height"]
    }],
    output: "validHeight"
}
// è®¡ç®—: validHeight = max(0, height)
```

---

### 3.5 ConstraintFactory (çº¦æŸå·¥å‚)

```javascript
// æ–‡ä»¶: constraintfactory.js (99857)
class ConstraintFactory {
    private static _instance: ConstraintFactory;
    
    static instance(): ConstraintFactory {
        if (!this._instance) {
            this._instance = new ConstraintFactory();
        }
        return this._instance;
    }
    
    // åˆ›å»ºçº¦æŸ
    createConstraint(data, stateMap): Constraint {
        // æ ¹æ®æ•°æ®åˆ¤æ–­çº¦æŸç±»å‹
        if (data.equation) {
            // æ–¹ç¨‹çº¦æŸ
            const constraint = new EquationConstraint();
            constraint.init(data, stateMap);
            return constraint;
        }
        
        // é»˜è®¤ä¸ºä½ç½®çº¦æŸ
        const constraint = new PositionConstraint();
        constraint.init(data, stateMap);
        return constraint;
    }
}
```

---

### 3.6 ConstraintHelper (çº¦æŸè¾…åŠ©å™¨)

```javascript
// æ–‡ä»¶: constrainthelper.js (223024)
class ConstraintHelper {
    private static _instance: ConstraintHelper;
    
    static getInstance(): ConstraintHelper {
        
if (!this._instance) {
            this._instance = new ConstraintHelper();
        }
        return this._instance;
    }
    
    // è·å–ç›¸å…³çº¦æŸ(å»é‡å’Œå†²çªæ£€æµ‹)
    getRelatedConstraint(
        constraint: SnapResult,
        candidateConstraints: SnapResult[]
    ): SnapResult | undefined {
        const uniqueConstraints = [];
        
        // è¿‡æ»¤å”¯ä¸€çº¦æŸ
        for (const candidate of candidateConstraints) {
            if (this._isUnique(constraint, candidate)) {
                uniqueConstraints.push(candidate);
            }
        }
        
        if (uniqueConstraints.length === 0) {
            return undefined;
        }
        
        // ç‰¹æ®Šå¤„ç†å…±çº¿çº¦æŸ
        if (constraint.type === SnapResultType.Colline) {
            // è¿‡æ»¤æ‰å¹³è¡Œçš„å…±çº¿çº¦æŸ
            const nonParallel = uniqueConstraints.filter(c => {
                if (c.type !== SnapResultType.Colline) return true;
                
                const geo1 = constraint.client.geo;
                const geo2 = c.client.geo;
                
                return !geo1.isParallelTo(geo2);
            });
            
            const collineConstraints = nonParallel.filter(c =>
                c.type === SnapResultType.Colline
            );
            
            if (collineConstraints.length === 0) {
                return nonParallel[0];
            }
            
            // é€‰æ‹©æ–¹å‘æœ€æ¥è¿‘çš„
            const clientGeo = constraint.client.geo;
            const sameDirection = collineConstraints.filter(c => {
                const cross = c.client.geo.getDirection()
                    .cross(clientGeo.getDirection());
                return cross < 0.001;
            });
            
            return sameDirection.length === 0 ? 
                nonParallel[0] : sameDirection[0];
        }
        
        return uniqueConstraints[0];
    }
    
    // æ‰§è¡Œçº¦æŸ(åˆå¹¶ç»“æœ)
    execute(
        constraint: SnapResult,
        additional?: SnapResult
    ): ConstraintResult {
        if (!constraint) return undefined;
        
        let result = {};
        result = Object.assign(result, constraint.getJSON());
        
        if (!additional) return result;
        
        // åˆå¹¶é¢å¤–çº¦æŸ
        if ((!result.dx || Math.abs(result.dx) < 1e-6) && additional.dx) {
            result = Object.assign(result, { dx: additional.dx });
        }
        
        if ((!result.dy || Math.abs(result.dy) < 1e-6) && additional.dy) {
            result = Object.assign(result, { dy: additional.dy });
        }
        
        if (!result.drotation && additional.drotation) {
            result = Object.assign(result, {
                drotation: additional.drotation,
                center: additional.center
            });
        }
        
        return result;
    }
    
    // æ£€æŸ¥çº¦æŸå”¯ä¸€æ€§(é¿å…å†²çª)
    private _isUnique(
        constraint1: SnapResult,
        constraint2: SnapResult
    ): boolean {
        const EPS = Tolerance.EDGE_LENGTH_EPS;
        
        // æ£€æŸ¥dxå†²çª
        if (constraint1.dx && Math.abs(constraint1.dx) > 1e-4 &&
            constraint2.dx && Math.abs(constraint2.dx) > 1e-4 &&
            Math.abs(constraint1.dx - constraint2.dx) > EPS) {
            return false;
        }
        
        // æ£€æŸ¥dyå†²çª
        if (constraint1.dy && Math.abs(constraint1.dy) > 1e-4 &&
            constraint2.dy && Math.abs(constraint2.dy) > 1e-4 &&
            Math.abs(constraint1.dy - constraint2.dy) > EPS) {
            return false;
        }
        
        // æ£€æŸ¥æ—‹è½¬å†²çª
        if (constraint1.drotation && Math.abs(constraint1.drotation) > 1e-4 &&
            constraint2.drotation && Math.abs(constraint2.drotation) > 1e-4 &&
            Math.abs(constraint1.drotation - constraint2.drotation) > EPS) {
            return false;
        }
        
        return true;
    }
}
```

**çº¦æŸè¾…åŠ©åŠŸèƒ½**:
- âœ… çº¦æŸå»é‡å’Œå†²çªæ£€æµ‹
- âœ… å…±çº¿çº¦æŸæ™ºèƒ½é€‰æ‹©
- âœ… çº¦æŸç»“æœåˆå¹¶
- âœ… å®¹å·®ç²¾åº¦æ§åˆ¶

---

## å››ã€2Då‡ ä½•ç®—æ³•åº“

### 4.1 MathAlg (å‡ ä½•ç®—æ³•å‘½åç©ºé—´)

åŸºäºæœç´¢ç»“æœ,ç³»ç»Ÿå®ç°äº†ä¸°å¯Œçš„2Då‡ ä½•ç®—æ³•:

```javascript
MathAlg = {
    // ç›¸äº¤è®¡ç®—
    Intersect: {
        curve2ds(curve1, curve2): Intersection[] {
            // è®¡ç®—ä¸¤æ¡2Dæ›²çº¿çš„äº¤ç‚¹
            // æ”¯æŒ: Line-Line, Line-Arc, Arc-Arc
            // è¿”å›: [{point, param1, param2}]
        }
    },
    
    // é‡å è®¡ç®—
    CalculateOverlap: {
        curve2ds(curve1, curve2, tolerance?): Overlap[] {
            // è®¡ç®—ä¸¤æ¡æ›²çº¿çš„é‡å éƒ¨åˆ†
            // è¿”å›: [{
            //   isSameDirection: boolean,
            //   range1: {min, max},
            //   range2: {min, max}
            // }]
        }
    },
    
    Overlap: {
        curve2ds(curve1, curve2): Overlap[] {
            // ç®€åŒ–ç‰ˆé‡å è®¡ç®—
        }
    },
    
    // è·ç¦»è®¡ç®—
    CalculateDistance: {
        pointToCurve2d(point: Point2d, curve: Curve2d): number {
            // ç‚¹åˆ°æ›²çº¿çš„æœ€çŸ­è·ç¦»
        }
    },
    
    Distance: {
        pointToCurve2d(point: Point2d, curve: Curve2d): number {
            // ç‚¹åˆ°æ›²çº¿è·ç¦»
        }
    },
    
    // ä½ç½®åˆ¤æ–­
    PositionJudge: {
        loopToLoop(loop1: Loop, loop2: Loop): LoopLoopPositonType {
            // ç¯ä¸ç¯çš„ä½ç½®å…³ç³»
            // è¿”å›: OUT(å¤–éƒ¨) | IN(å†…éƒ¨) | OVERLAP(é‡å )
        },
        
        ptToLoop(point: Point2d, loop: Loop, tolerance): {
            type: PtLoopPositonType  // ONEDGE | ONVERTEX | INSIDE | OUTSIDE
        } {
            // ç‚¹ä¸ç¯çš„ä½ç½®å…³ç³»
        }
    },
    
    // 2Då¸ƒå°”è¿ç®—
    Bool2d: {
        boolOperate(
            polygons: Polygon[], 
            holes: Polygon[], 
            operation: Bool2dType
        ): Polygon[] {
            // 2Då¸ƒå°”è¿ç®—
            // operation: union | intersection | difference
        }
    },
    
    BoolOperate2d: {
        union(loops: Loop[]): Polygon[] {
            // å¹¶é›†è¿ç®—
            return Polygon[].getLoops();
        },
        
        intersection(loops: Loop[]): Polygon[] {
            // äº¤é›†è¿ç®—
        },
        
        difference(base: Loop, subtract: Loop[]): Polygon[] {
            // å·®é›†è¿ç®—
        }
    }
}
```

---

### 4.2 2Dæ›²çº¿ç›¸äº¤ç®—æ³•ä½¿ç”¨æ¨¡å¼

åŸºäºä»£ç æœç´¢(144ä¸ªç»“æœ),ç³»ç»Ÿå¤§é‡ä½¿ç”¨æ›²çº¿ç›¸äº¤ç®—æ³•:

**æ¨¡å¼1: ç›´çº¿-ç›´çº¿ç›¸äº¤**

```javascript
// walljoint.js - å¢™ä½“è¿æ¥ç‚¹è®¡ç®—
const wall1Curve = wall1.curve;
const wall2Curve = wall2.curve;

const intersections = MathAlg.CalculateIntersect.curve2ds(
    TgWallUtil.extendCurve(wall1Curve),
    TgWallUtil.extendCurve(wall2Curve)
);

if (intersections.length > 0) {
    const jointPoint = intersections[0].point;
    // ä½¿ç”¨äº¤ç‚¹ä½œä¸ºå¢™ä½“è¿æ¥ç‚¹
}
```

**æ¨¡å¼2: æ›²çº¿é‡å æ£€æµ‹**

```javascript
// slabutil_2.js - æ¿ä¸è¾¹é‡å åˆ¤æ–­
const line = new Line2d(edge.getStartPt(), edge.getEndPt());
const overlaps = MathAlg.CalculateOverlap.curve2ds(
    line, 
    boundCurve,
    new Tolerance(precision)
);

if (overlaps.length === 1 &&
    overlaps[0].isSameDirection &&
    overlaps[0].range1.getLength() >= 1e-4 &&
    overlaps[0].range2.getLength() >= 1e-4) {
    // å­˜åœ¨æœ‰æ•ˆé‡å 
    const overlapDirection = line.getDirection().normalized()
        .equals(boundCurve.getDirection());
}
```

**æ¨¡å¼3: åœ†å¼§ä¸‰ç‚¹åˆ›å»º**

```javascript
// sketch2brephelper.js - æ‹Ÿåˆåœ†å¼§è¾¹
const arc = Arc2d.makeArcByThreePoints(
    startPoint,
    midPoint,
    endPoint
);

if (!arc) {
    console.assert(false, "arc2d creation failed");
}
```

**æ¨¡å¼4: ç¯ä¸ç¯ä½ç½®åˆ¤æ–­**

```javascript
// roomutil_2.js - æˆ¿é—´è½®å»“åŒ…å«åˆ¤æ–­
const profileLoop = new Loop(room.profile);
const targetLoop = new Loop(target.profile);

const relation = MathAlg.PositionJudge.loopToLoop(
    profileLoop,
    targetLoop
);

if (relation === MathAlg.LoopLoopPositonType.OUT) {
    // targetLoopåœ¨å¤–éƒ¨
} else if (relation === MathAlg.LoopLoopPositonType.IN) {
    // targetLoopåœ¨å†…éƒ¨
} else {
    // é‡å 
}

// æ£€æŸ¥æ˜¯å¦æœ‰è¾¹é‡å 
const hasEdgeOverlap = profileLoop.getAllCurves().some(curve1 =>
    targetCurves.some(curve2 =>
        MathAlg.Overlap.curve2ds(curve1, curve2).length > 0
    )
);
```

---

## äº”ã€2Då‡ ä½•ä¸3D BREPçš„æ¡¥æ¥

### 5.1 Surface.getCurve2d() - 3Dæ›²çº¿æŠ•å½±åˆ°2D

```javascript
// ä½¿ç”¨åœºæ™¯: å°†3D BREPè¾¹æŠ•å½±åˆ°é¢çš„UVç©ºé—´

// ç¤ºä¾‹1: è·å–é¢çš„2Dè¾¹ç•Œ
const face = brep.getFaces()[0];
const surface = face.getSurface();

const loops2d = face.getWires().map(wire => {
    const curves2d = wire.getCoedge3ds().map(coedge => {
        const curve3d = coedge.getCurve();
        const curve2d = surface.getCurve2d(curve3d);
        return curve2d;
    });
    
    return new Loop(curves2d);
});

// ç¤ºä¾‹2: 2Då¸ƒå°”è¿ç®—å‡†å¤‡
face.getWires().forEach(wire => {
    wire.getCoedge3ds().forEach(coedge => {
        const curve3d = coedge.getCurve();
        const curve2d = plane.getCurve2d(curve3d);
        
        // åœ¨2Dç©ºé—´æ‰§è¡Œå¸ƒå°”è¿ç®—
    });
});
```

### 5.2 Plane.getCurve3d() - 2Dæ›²çº¿æå‡åˆ°3D

```javascript
// ä½¿ç”¨åœºæ™¯: å°†2Dè‰å›¾æ›²çº¿è½¬æ¢ä¸º3Dè¾¹

// baseboardtopopather.js - è¸¢è„šçº¿è·¯å¾„ç”Ÿæˆ
const curve2d = edge.curve;  // 2Dæ›²çº¿

const pathItem = {
    curve3d: 
Plane.XOY().getCurve3d(curve2d),  // æå‡åˆ°XYå¹³é¢
    curve2d: curve2d,                           // ä¿ç•™2Då¼•ç”¨
    zlimit: 10                                  // Zè½´é™åˆ¶
};

// å¦ä¸€ä¸ªç¤ºä¾‹
const path3d = {
    curve3d: Plane.XOY().getCurve3d(edgeCurve.curve),
    curve2d: edgeCurve.curve
};
```

### 5.3 2Då¸ƒå°”è¿ç®—åº”ç”¨

```javascript
// ä½¿ç”¨åœºæ™¯: å¢™ä½“-å¼€å­”-æˆ¿é—´çš„å¤æ‚å¸ƒå°”è¿ç®—

// contentutil.js - åˆå¹¶å¤šä¸ªæˆ¿é—´è½®å»“
const roomLoops = rooms.map(room => room.profile);

// æ‰§è¡Œå¹¶é›†è¿ç®—
const unionResult = MathAlg.Bool2d.boolOperate(
    roomLoops,
    [],  // æ— å­”
    MathAlg.Bool2dType.union
);

// è·å–åˆå¹¶åçš„ç¯
const mergedLoops = unionResult[0].getLoops();

// tgslabutil.js - æ¿å­”æ´å¤„ç†
const polygons = holes.map(hole => new Polygon(hole.curves));

const unionPolygons = MathAlg.BoolOperate2d.union(polygons);
const outerLoops = unionPolygons.getLoops()
    .filter(loop => loop.isAnticlockwise());  // åªå–å¤–ç¯

outerLoops.forEach(loop => {
    // å¤„ç†åˆå¹¶åçš„å­”æ´
});
```

---

## å…­ã€çº¦æŸç³»ç»Ÿå·¥ä½œæµç¨‹

### 6.1 å®Œæ•´çº¦æŸæ±‚è§£æµç¨‹

```
1. åˆ›å»ºStateå¯¹è±¡
   â†“
2. å®šä¹‰Constraintå…³ç³»
   â†“
3. ConstraintManageræ³¨å†Œ
   â†“
4. è§¦å‘compute()æ±‚è§£
   â†“
5. State.valueæ›´æ–°
   â†“
6. å‡ ä½•å›¾å½¢æ›´æ–°
```

### 6.2 çº¦æŸç®¡ç†å™¨é›†æˆ

```javascript
// æ–‡æ¡£çº§åˆ«ç®¡ç†
class Document {
    stateManager: Cache<State>;         // çŠ¶æ€ç®¡ç†å™¨
    constraintManager: Cache<Constraint>; // çº¦æŸç®¡ç†å™¨
    
    constructor() {
        this.stateManager = new Cache("HSCore.StateManager");
        this.constraintManager = new Cache("HSCore.StateManager");
    }
    
    // åºåˆ—åŒ–
    toJSON(): DocumentJSON {
        const states = this.stateManager.getAll();
        const constraints = this.constraintManager.getAll();
        
        return {
            states: states,
            constraints: constraints,
            // ... å…¶ä»–æ•°æ®
        };
    }
    
    // ååºåˆ—åŒ–
    fromJSON(json: DocumentJSON): void {
        // åŠ è½½çŠ¶æ€
        json.states.forEach(stateData => {
            const state = State.loadFromDump(stateData, context);
            this.stateManager.add(state);
        });
        
        // åŠ è½½çº¦æŸ
        json.constraints.forEach(constraintData => {
            const constraint = Constraint.loadFromDump(
                constraintData,
                context
            );
            this.constraintManager.add(constraint);
        });
    }
    
    // æ¸…ç†
    clear(): void {
        this.stateManager.clear();
        this.constraintManager.clear();
    }
}
```

### 6.3 å‚æ•°åŒ–æ¨¡å‹çº¦æŸé›†æˆ

```javascript
// å‚æ•°åŒ–æ¨¡å‹ä½¿ç”¨çº¦æŸç³»ç»Ÿ
class ParametricModel extends Entity {
    states: {id: State} = {}          // çŠ¶æ€å­—å…¸
    constraints: {id: Constraint} = {} // çº¦æŸå­—å…¸
    
    // æ·»åŠ çº¦æŸ
    addConstraint(constraint: Constraint): void {
        if (this.constraints[constraint.localId]) {
            console.assert(false, "Constraint already exists");
            return;
        }
        
        this.constraints[constraint.localId] = constraint;
    }
    
    // ç§»é™¤çº¦æŸ
    removeConstraint(constraint: Constraint): void {
        delete this.constraints[constraint.localId];
    }
    
    // æ ¹æ®çŠ¶æ€æŸ¥æ‰¾ç›¸å…³çº¦æŸ
    getConstraintsByState(stateId: string): Constraint[] {
        const result = [];
        
        Object.values(this.constraints).forEach(constraint => {
            // æ£€æŸ¥è¾“å…¥
            if (Object.values(constraint.inputs)
                .find(s => s.localId === stateId)) {
                result.push(constraint);
            }
            
            // æ£€æŸ¥è¾“å‡º
            if (Object.values(constraint.outputs)
                .find(s => s.localId === stateId)) {
                result.push(constraint);
            }
        });
        
        return result;
    }
    
    // ç§»é™¤çŠ¶æ€æ—¶æ¸…ç†ç›¸å…³çº¦æŸ
    removeStateAndConstraints(stateId: string): void {
        if (!stateId) return;
        
        // ç§»é™¤çº¦æŸ
        if (this.constraints[stateId]) {
            this.removeConstraint(this.constraints[stateId]);
        }
        
        // æŸ¥æ‰¾å¹¶ç§»é™¤ä¾èµ–è¯¥çŠ¶æ€çš„çº¦æŸ
        const relatedConstraints = [];
        Object.values(this.constraints).forEach(constraint => {
            const hasInput = Object.values(constraint.inputs)
                .some(s => s.localId === stateId);
            const hasOutput = Object.values(constraint.outputs)
                .some(s => s.localId === stateId);
            
            if (hasInput || hasOutput) {
                relatedConstraints.push(constraint);
            }
        });
        
        relatedConstraints.forEach(c => this.removeConstraint(c));
    }
    
    // è®¡ç®—æ‰€æœ‰çº¦æŸ
    compute(): void {
        // æ‹“æ‰‘æ’åºçº¦æŸ
        const sortedConstraints = this._topologicalSortConstraints();
        
        // æŒ‰é¡ºåºè®¡ç®—
        sortedConstraints.forEach(constraint => {
            constraint.compute();
        });
    }
    
    // çº¦æŸæ‹“æ‰‘æ’åº
    private _topologicalSortConstraints(): Constraint[] {
        const constraints = Object.values(this.constraints);
        const sorted = [];
        const visited = new Set();
        
        // DFSæ’åº
        const visit = (constraint: Constraint) => {
            if (visited.has(constraint.id)) return;
            
            visited.add(constraint.id);
            
            // å…ˆè®¿é—®ä¾èµ–çš„çº¦æŸ
            Object.values(constraint.inputs).forEach(inputState => {
                const producers = constraints.filter(c =>
                    Object.values(c.outputs).includes(inputState)
                );
                producers.forEach(visit);
            });
            
            sorted.push(constraint);
        };
        
        constraints.forEach(visit);
        
        return sorted;
    }
    
    // éªŒè¯çº¦æŸç³»ç»Ÿ
    verify(): boolean {
        // æ£€æŸ¥æ‰€æœ‰çŠ¶æ€
        const invalidState = Object.values(this.states)
            .find(s => !s.verify());
        
        if (invalidState) return false;
        
        // æ£€æŸ¥æ‰€æœ‰çº¦æŸ
        const invalidConstraint = Object.values(this.constraints)
            .find(c => {
                // çº¦æŸæœ¬èº«éªŒè¯
                if (!c.verify()) return true;
                
                // è¾“å…¥çŠ¶æ€å­˜åœ¨æ€§
                const missingInput = Object.values(c.inputs)
                    .find(s => !this.states[s.localId]);
                if (missingInput) return true;
                
                // è¾“å‡ºçŠ¶æ€å­˜åœ¨æ€§
                const missingOutput = Object.values(c.outputs)
                    .find(s => !this.states[s.localId]);
                if (missingOutput) return true;
                
                return false;
            });
        
        return !invalidConstraint;
    }
}
```

---

## ä¸ƒã€å®é™…åº”ç”¨åœºæ™¯

### 7.1 å¢™ä½“ç»˜åˆ¶çº¦æŸ

```javascript
// å¢™ä½“é•¿åº¦çº¦æŸ
{
    type: "EquationConstraint",
    equation: "wallLength = endX - startX",
    inputs: {startX, endX},
    outputs: {wallLength}
}

// å¢™ä½“å¹³è¡Œçº¦æŸ
{
    type: "PositionConstraint",
    inputs: [{
        method: "add",
        states: ["wall1Angle", "parallelOffset"]
    }],
    output: "wall2Angle"
}
```

### 7.2 å¼€å­”ä½ç½®çº¦æŸ

```javascript
// é—¨çª—å±…ä¸­çº¦æŸ
{
    type: "EquationConstraint",
    equation: "openingX = (wallLength - openingWidth) / 2",
    inputs: {wallLength, openingWidth},
    outputs: {openingX}
}

// é—¨çª—é«˜åº¦çº¦æŸ
{
    type: "PositionConstraint",
    inputs: [{
        method: "sub",
        states: ["floorHeight", "openingHeight"]
    }],
    output: "openingBottom"
}
```

### 7.3 æˆ¿é—´è½®å»“çº¦æŸ

```javascript
// æˆ¿é—´é¢ç§¯çº¦æŸ
{
    type: "EquationConstraint",
    equation: "area = width * height",
    inputs: {width, height},
    outputs: {area}
}

// æˆ¿é—´æ¯”ä¾‹çº¦æŸ
{
    type: "EquationConstraint",
    equation: "aspectRatio = width / height",
    inputs: {width, height},
    outputs: {aspectRatio}
}
```

---

## å…«ã€2Då‡ ä½•å†…æ ¸ç‰¹æ€§æ€»ç»“

### 8.1 æ ¸å¿ƒä¼˜åŠ¿

| ç‰¹æ€§ | è¯´æ˜ | å®ç°æ–¹å¼ |
|------|------|---------|
| **å‚æ•°åŒ–é©±åŠ¨** | æ‰€æœ‰å‡ ä½•å›¾å½¢ç”±çº¦æŸæ§åˆ¶ | State + Constraintç³»ç»Ÿ |
| **å®æ—¶æ±‚è§£** | å‚æ•°å˜åŒ–è‡ªåŠ¨æ›´æ–°å‡ ä½• | çº¦æŸæ‹“æ‰‘æ’åº+å¢é‡è®¡ç®— |
| **ç²¾ç¡®è®¡ç®—** | ä¿ç•™ç²¾ç¡®çš„å‡ ä½•è¡¨ç¤º | Arc2dä¿ç•™åœ†å¿ƒåŠå¾„,éç¦»æ•£åŒ– |
| **å®¹å·®æ§åˆ¶** | å¯é…ç½®çš„ç²¾åº¦é˜ˆå€¼ | Tolerance.EDGE_LENGTH_EPS |
| **2D-3Dæ¡¥æ¥** | æ— ç¼è½¬æ¢2Dè‰å›¾åˆ°3Dæ¨¡å‹ | getCurve2d/getCurve3d |
| **å¸ƒå°”è¿ç®—** | å®Œæ•´çš„2Då¸ƒå°”æ“ä½œ | MathAlg.Bool2d |

### 8.2 çº¦æŸç±»å‹è¦†ç›–

| çº¦æŸç±»å‹ | å®ç°ç±» | åŠŸèƒ½ | åº”ç”¨ |
|---------|--------|------|------|
| **æ–¹ç¨‹çº¦æŸ** | EquationConstraint | JavaScriptè¡¨è¾¾å¼æ±‚è§£ | å°ºå¯¸è®¡ç®—ã€é¢ç§¯ã€æ¯”ä¾‹ |
| **ä½ç½®çº¦æŸ** | PositionConstraint | é“¾å¼æ•°å€¼è®¡ç®— | åç§»ã€ç¼©æ”¾ã€ç´¯åŠ  |
| **å‡ ä½•çº¦æŸ** | (éšå¼) | å¹³è¡Œã€å‚ç›´ã€å…±çº¿ | å¢™ä½“å¯¹é½ã€å¼€å­”å¯¹é½ |

### 8.3 æ€§èƒ½ç‰¹å¾

- **çº¦æŸæ±‚è§£**: O(n) çº¿æ€§æ—¶é—´(æ‹“æ‰‘æ’åº)
- **æ›²çº¿ç›¸äº¤**: O(1) è§£æè§£(ç›´çº¿-ç›´çº¿)
- **å¸ƒå°”è¿ç®—**: ä¾èµ–åº•å±‚ç®—æ³•åº“(TgWallUtil.PTInstance)
- **ç‚¹åœ¨å¤šè¾¹å½¢å†…**: O(n) å°„çº¿æ³•

---

## ä¹ã€ä¸3D BREPçš„åä½œæ¨¡å¼

### 9.1 å…¸å‹å·¥ä½œæµ

```
ç”¨æˆ·è‰å›¾ç»˜åˆ¶ (2D)
    â†“
åº”ç”¨çº¦æŸæ±‚è§£ (2D Constraint)
    â†“
ç”Ÿæˆ2Dè½®å»“ (Polygon2d)
    â†“
æå‡åˆ°3D (getCurve3d)
    â†“
æ‹‰ä¼¸/æ‰«æ  (WebCADModelAPI)
    â†“
ç”ŸæˆBREPå®ä½“ (3D Face/Edge/Vertex)
    â†“
æŠ•å½±å›2D (getCurve2d)
    â†“
2Dç¼–è¾‘ä¿®æ”¹
    â†“
æ›´æ–°3Dæ¨¡å‹
```

### 9.2 æ•°æ®æµè½¬




```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2Dç©ºé—´ (Sketch/è‰å›¾å±‚)                      â”‚
â”‚  - Curve2d (Line2d, Arc2d, Circle2d)       â”‚
â”‚  - Polygon2d (å¸¦å­”å¤šè¾¹å½¢)                   â”‚
â”‚  - Constraint (å‚æ•°åŒ–çº¦æŸ)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              â†• è½¬æ¢                         â”‚
â”‚  surface.getCurve2d(curve3d)                â”‚
â”‚  plane.getCurve3d(curve2d)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  3Dç©ºé—´ (BREPæ‹“æ‰‘å±‚)                        â”‚
â”‚  - Face (å¸¦Surfaceçš„é¢)                     â”‚
â”‚  - Edge (3Dæ›²çº¿è¾¹)                          â”‚
â”‚  - Vertex (3Dé¡¶ç‚¹)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## åã€å…³é”®å‘ç°ä¸ç»“è®º

### 10.1 2Då‡ ä½•å†…æ ¸ç‰¹å¾

**âœ… è‡ªå®šä¹‰å®ç°ç¨‹åº¦: 90%**

| ç»„ä»¶ | è‡ªå®šä¹‰/ç¬¬ä¸‰æ–¹ | è¯´æ˜ |
|------|-------------|------|
| Curve2dåŸºç±» | è‡ªå®šä¹‰ | å®Œæ•´å®ç° |
| Arc2d/Line2d | è‡ªå®šä¹‰ | å®Œæ•´å®ç° |
| Polygon2d | è‡ªå®šä¹‰ | å¸¦å­”å¤šè¾¹å½¢ |
| Constraintç³»ç»Ÿ | è‡ªå®šä¹‰ | å®Œæ•´çº¦æŸæ±‚è§£å™¨ |
| MathAlgç®—æ³•åº“ | è‡ªå®šä¹‰ | ç›¸äº¤/é‡å /å¸ƒå°”è¿ç®— |
| GeLibé›†æˆ | ç¬¬ä¸‰æ–¹ | ä»…ç”¨äºè¾…åŠ©è®¡ç®— |
| THREE.jsé›†æˆ | ç¬¬ä¸‰æ–¹ | ä»…ç”¨äºæ›²çº¿è¡¨ç¤º |

**ğŸ”‘ æ ¸å¿ƒèƒ½åŠ›**:

1. **å‚æ•°åŒ–å‡ ä½•**: å®Œæ•´çš„çº¦æŸæ±‚è§£ç³»ç»Ÿ
2. **ç²¾ç¡®è¡¨ç¤º**: ä¿ç•™è§£æå‡ ä½•(éç¦»æ•£åŒ–)
3. **æ‹“æ‰‘ä¸€è‡´æ€§**: Wire-Curveçˆ¶å­å…³ç³»ç®¡ç†
4. **2D-3Däº’è½¬**: SurfaceæŠ•å½±/æå‡æœºåˆ¶

### 10.2 çº¦æŸç³»ç»Ÿç‰¹å¾

**çº¦æŸç±»å‹**:
- EquationConstraint: JavaScriptè¡¨è¾¾å¼æ±‚è§£ (ä½¿ç”¨Esprimaè§£æ)
- PositionConstraint: é“¾å¼æ•°å€¼è®¡ç®— (add/sub/mul/div)

**æ±‚è§£ç­–ç•¥**:
- æ‹“æ‰‘æ’åº: è‡ªåŠ¨å¤„ç†çº¦æŸä¾èµ–
- å¢é‡è®¡ç®—: åªé‡ç®—å—å½±å“çš„çº¦æŸ
- å†²çªæ£€æµ‹: ConstraintHelperå»é‡

**åº”ç”¨èŒƒå›´**:
- å¢™ä½“å°ºå¯¸å’Œä½ç½®
- å¼€å­”å‚æ•°
- æˆ¿é—´è½®å»“
- å‚æ•°åŒ–æ¨¡å‹

### 10.3 ä¸3D BREPçš„å…³ç³»

**åä½œæ¨¡å¼**:

```javascript
// 2Dè‰å›¾ â†’ 3Dæ¨¡å‹
const sketch2d = createSketch();          // 2D Polygon2d
const curves3d = sketch2d.outer.curves    // 2D Curve2d[]
    .map(c => Plane.XOY().getCurve3d(c)); // 3D Curve3d[]

const brep = WebCADModelAPI.extrudePath(  // æ‹‰ä¼¸ç”ŸæˆBREP
    curves3d,
    height
);

// 3Dæ¨¡å‹ â†’ 2Dç¼–è¾‘
const face = brep.getFaces()[0];
const surface = face.getSurface();

const curves2d = face.getWires()[0]       // 3D Wire
    .getCoedge3ds()                       // 3D CoEdge[]
    .map(ce => surface.getCurve2d(        // æŠ•å½±åˆ°2D
        ce.getCurve()
    ));

const polygon2d = new Polygon2d();
polygon2d.outer.curves = curves2d;

// ä¿®æ”¹2D â†’ æ›´æ–°3D
polygon2d.outer.curves[0] = modifiedCurve2d;
const newCurves3d = polygon2d.outer.curves
    .map(c => surface.getCurve3d(c));

const newBrep = rebuildBrepFromCurves(newCurves3d);
```

---

## åä¸€ã€ä»£ç ç¤ºä¾‹æ±‡æ€»

### 11.1 å®Œæ•´çš„å‚æ•°åŒ–çŸ©å½¢

```javascript
// åˆ›å»ºå‚æ•°åŒ–æ¨¡å‹
const model = new ParametricModel();

// å®šä¹‰çŠ¶æ€
const states = {
    x: new State("x", 100),
    y: new State("y", 100),
    width: new State("width", 500),
    height: new State("height", 300)
};

Object.values(states).forEach(s => {
    model.states[s.localId] = s;
});

// æ·»åŠ çº¦æŸ
const constraints = [
    // å³ä¾§X = å·¦ä¾§X + å®½åº¦
    {
        equation: "x2 = x + width",
        inputs: {x: states.x, width: states.width},
        outputs: {x2: new State("x2", 0)}
    },
    // é¡¶éƒ¨Y = åº•éƒ¨Y + é«˜åº¦
    {
        equation: "y2 = y + height",
        inputs: {y: states.y, height: states.height},
        outputs: {y2: new State("y2", 0)}
    }
];

constraints.forEach(data => {
    const constraint = new EquationConstraint();
    constraint.init(data, states);
    model.addConstraint(constraint);
});

// è®¡ç®—çº¦æŸ
model.compute();

// åˆ›å»ºå‡ ä½•
const polygon = Polygon2d.create({
    outer: {
        curves: [
            new Line2d({x: states.x.value, y: states.y.value},
                      {x: states.x2.value, y: states.y.value}),
            new Line2d({x: states.x2.value, y: states.y.value},
                      {x: states.x2.value, y: states.y2.value}),
            new Line2d({x: states.x2.value, y: states.y2.value},
                      {x: states.x.value, y: states.y2.value}),
            new Line2d({x: states.x.value, y: states.y2.value},
                      {x: states.x.value, y: states.y.value})
        ]
    },
    holes: []
});

// ä¿®æ”¹å‚æ•°
states.width.value = 800;  // æ”¹å˜å®½åº¦
model.compute();            // é‡æ–°è®¡ç®—çº¦æŸ

// x2è‡ªåŠ¨æ›´æ–°ä¸º: 100 + 800 = 900
console.log(states.x2.value);  // 900
```

### 11.2 å¸¦çº¦æŸçš„è‰å›¾ç¼–è¾‘

```javascript
// è‰å›¾ç¼–è¾‘å™¨å·¥ä½œæµ
class SketchEditor {
    model: ParametricModel;
    polygon: Polygon2d;
    
    // æ·»åŠ æ°´å¹³çº¦æŸ
    addHorizontalConstraint(line: Line2d): void {
        const constraint = new EquationConstraint();
        constraint.equation = "dy = 0";
        constraint.outputs = {dy: line.dyState};
        
        this.model.addConstraint(constraint);
        this.model.compute();
        
        // lineè‡ªåŠ¨å˜ä¸ºæ°´å¹³
    }
    
    // æ·»åŠ å‚ç›´çº¦æŸ
    addVerticalConstraint(line: Line2d): void {
        const constraint = new EquationConstraint();
        constraint.equation = "dx = 0";
        constraint.outputs = {dx: line.dxState};
        
        this.model.addConstraint(constraint);
        this.model.compute();
        
        // lineè‡ªåŠ¨å˜ä¸ºå‚ç›´
    }
    
    // æ·»åŠ é•¿åº¦çº¦æŸ
    addLengthConstraint(line: Line2d, length: number): void {
        const constraint = new EquationConstraint();
        constraint.equation = `lineLength = ${length}`;
        constraint.outputs = {lineLength: line.lengthState};
        
        this.model.addConstraint(constraint);
        this.model.compute();
        
        // lineé•¿åº¦å›ºå®šä¸ºæŒ‡å®šå€¼
    }
    
    // æ·»åŠ å¹³è¡Œçº¦æŸ
    addParallelConstraint(line1: Line2d, line2: Line2d): void {
        const constraint = new EquationConstraint();
        constraint.equation = "angle2 = angle1";
        constraint.inputs = {angle1: line1.angleState};
        constraint.outputs = {angle2: line2.angleState};
        
        this.model.addConstraint(constraint);
        this.model.compute();
        
        // line2è‡ªåŠ¨å¹³è¡Œäºline1
    }
}
```

---

## åäºŒã€æŠ€æœ¯äº®ç‚¹

### 12.1 Esprimaé›†æˆ (JavaScriptè¡¨è¾¾å¼è§£æ)

```javascript
// EquationConstraintä½¿ç”¨Esprimaè§£æè¡¨è¾¾å¼
const equation = "totalLength = length1 + length2 * 2";

// è§£æAST
const ast = Esprima.parse(equation);
// {
//   type: "Program",
//   body: [{
//     type: "ExpressionStatement",
//     expression: {
//       type: "AssignmentExpression",
//       left: {type: "Identifier", name: "totalLength"},
//       right: {type: "BinaryExpression", operator: "+", ...}
//     }
//   }]
// }

// æå–æ ‡è¯†ç¬¦
const tokens = Esprima.tokenize(equation);
// [{type: "Identifier", value: "totalLength"},
//  {type: "Punctuator", value: "="},
//  {type: "Identifier", value: "length1"},
//  {type: "Punctuator", value: "+"},
//  {type: "Identifier", value: "length2"},
//  {type: "Punctuator", value: "*"},
//  {type: "Numeric", value: "2"}]

// è‡ªåŠ¨å»ºç«‹ä¾èµ–å…³ç³»
// outputs: [totalLength]
// inputs: [length1, length2]
```

### 12.2 å°„çº¿æ³•ç‚¹åœ¨å¤šè¾¹å½¢å†…åˆ¤æ–­

```javascript
// Polygon2d.isPointInside() å®ç°
function isPointInside(point: Point2d): boolean {
    const intersections = [];
    
    // æ”¶é›†ä¸æ°´å¹³å°„çº¿çš„æ‰€æœ‰äº¤ç‚¹
    for (const curve of getAllCurves()) {
        const points = curve.hLineIntersections(point.y);
        intersections.push(...points);
    }
    
    // ç»Ÿè®¡ç‚¹å³ä¾§çš„äº¤ç‚¹æ•°
    let inside = false;
    for (const pt of intersections) {
        if (pt.x > point.x) {
            inside = !inside;  // å¥‡æ•°æ¬¡ä¸ºå†…éƒ¨
        }
    }
    
    return inside;
}

// Arc2d.hLineIntersections() å®ç°
function hLineIntersections(y: number): Point2d[] {
    // 1. åˆ›å»ºæ°´å¹³çº¿
    const hLine = GeLib.LineUtils.toTHREELine3(
        {x: 0, y: y},
        {x: 1, y: y}
    );
    
    // 2. è®¡ç®—ä¸åœ†å¼§çš„äº¤ç‚¹
    const arc = this._toThreeCurve();
    const info = GeLib.CurveUtils.getIntersectionInfo(arc, hLine);
    
    // 3. è¿‡æ»¤å‚æ•°èŒƒå›´[0,1]å†…çš„äº¤ç‚¹
    const results = [];
    for (let i = 0; i < info.intersects.length; i++) {
        const param = info.thisParams[i];
        if (param >= 0 && param <= 1) {
            results.push(info.intersects[i]);
        }
    }
    
    return results;
}
```

### 12.3 çº¦æŸæ‹“æ‰‘æ’åº (ä¾èµ–è§£æ)

```javascript
// è‡ªåŠ¨å¤„ç†çº¦æŸä¾èµ–é¡ºåº
function topologicalSortConstraints(constraints: Constraint[]): Constraint[] {
    const sorted = [];
    const visited = new Set<string>();
    
    function 

visit(constraint: Constraint): void {
        if (visited.has(constraint.id)) return;
        
        visited.add(constraint.id);
        
        // å…ˆè®¿é—®ä¾èµ–çš„çº¦æŸ(äº§ç”Ÿè¾“å…¥çŠ¶æ€çš„çº¦æŸ)
        Object.values(constraint.inputs).forEach(inputState => {
            // æŸ¥æ‰¾äº§ç”Ÿè¯¥çŠ¶æ€çš„çº¦æŸ
            const producers = constraints.filter(c =>
                Object.values(c.outputs)
                    .some(s => s.id === inputState.id)
            );
            
            producers.forEach(visit);
        });
        
        // æ·»åŠ å½“å‰çº¦æŸ
        sorted.push(constraint);
    }
    
    // è®¿é—®æ‰€æœ‰çº¦æŸ
    constraints.forEach(visit);
    
    return sorted;
}

// ç¤ºä¾‹:
// Constraint1: width = 100
// Constraint2: height = 200  
// Constraint3: area = width * height
// Constraint4: perimeter = (width + height) * 2
//
// æ’åºç»“æœ: [Constraint1, Constraint2, Constraint3, Constraint4]
// æˆ–: [Constraint2, Constraint1, Constraint3, Constraint4]
// (Constraint1å’ŒConstraint2æ— ä¾èµ–,é¡ºåºå¯äº¤æ¢)
```

---

## åä¸‰ã€æ€§èƒ½ä¸ä¼˜åŒ–

### 13.1 çº¦æŸæ±‚è§£æ€§èƒ½

**æ—¶é—´å¤æ‚åº¦**:
- å•ä¸ªçº¦æŸè®¡ç®—: O(1)
- æ‹“æ‰‘æ’åº: O(V + E) (V=çº¦æŸæ•°, E=ä¾èµ–è¾¹æ•°)
- æ€»æ±‚è§£æ—¶é—´: O(n) çº¿æ€§

**ä¼˜åŒ–ç­–ç•¥**:
1. **å¢é‡è®¡ç®—**: åªé‡ç®—å—å½±å“çš„çº¦æŸ
2. **ç¼“å­˜éªŒè¯**: é¿å…é‡å¤éªŒè¯
3. **æ‡’åŠ è½½**: æŒ‰éœ€åŠ è½½çº¦æŸ

### 13.2 2Då‡ ä½•ç®—æ³•æ€§èƒ½

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ä¼˜åŒ– |
|------|----------|------|
| ç›´çº¿-ç›´çº¿ç›¸äº¤ | O(1) | è§£æè§£ |
| ç›´çº¿-åœ†å¼§ç›¸äº¤ | O(1) | GeLibåŠ é€Ÿ |
| åœ†å¼§-åœ†å¼§ç›¸äº¤ | O(1) | GeLibåŠ é€Ÿ |
| æ›²çº¿é‡å æ£€æµ‹ | O(n) | æå‰å‰”é™¤ |
| ç‚¹åœ¨å¤šè¾¹å½¢å†… | O(n) | å°„çº¿æ³• |
| 2Då¸ƒå°”è¿ç®— | O(n log n) | æ‰«æçº¿ç®—æ³• |

### 13.3 å†…å­˜ç®¡ç†

```javascript
// Entityç”Ÿå‘½å‘¨æœŸç®¡ç†
class Curve2d extends Entity {
    destroy(): void {
        // ä»çˆ¶çº§Wireä¸­ç§»é™¤
        Object.values(this.parents).forEach(parent => {
            parent.removeChild(this);
        });
        
        super.destroy();
    }
}

// Constraintç”Ÿå‘½å‘¨æœŸ
class Constraint extends Entity {
    destroy(): void {
        // æ¸…ç†è¾“å…¥è¾“å‡ºå¼•ç”¨
        this.inputs = {};
        this.outputs = {};
        
        // ä»ConstraintManagerç§»é™¤
        if (this.manager) {
            this.manager.remove(this);
        }
        
        super.destroy();
    }
}
```

---

## åå››ã€2Då†…æ ¸æ€»ç»“

### 14.1 æ¶æ„è¯„ä¼°

**ä¼˜åŠ¿** âœ…:
1. **å®Œå…¨è‡ªä¸»å¯æ§**: 90%è‡ªå®šä¹‰å®ç°
2. **å‚æ•°åŒ–èƒ½åŠ›å¼º**: çº¦æŸé©±åŠ¨çš„å‚æ•°åŒ–å»ºæ¨¡
3. **ç²¾ç¡®å‡ ä½•è¡¨ç¤º**: ä¿ç•™è§£æå½¢å¼,éç½‘æ ¼åŒ–
4. **ä¸3Dæ— ç¼é›†æˆ**: getCurve2d/3dåŒå‘è½¬æ¢
5. **æ‰©å±•æ€§å¥½**: æ˜“äºæ·»åŠ æ–°çº¦æŸç±»å‹
6. **JavaScriptå‹å¥½**: Esprimaè§£æè¡¨è¾¾å¼çº¦æŸ

**å±€é™** âš ï¸:
1. çº¦æŸæ±‚è§£ä¸º**å•å‘ä¼ æ’­**,éåŒå‘æ±‚è§£å™¨
2. æ— å…¨å±€ä¼˜åŒ–(å¦‚SolveSpaceçš„LMç®—æ³•)
3. çº¦æŸå†²çªæ£€æµ‹è¾ƒç®€å•(ä»…æ•°å€¼å¯¹æ¯”)
4. ç¼ºå°‘é«˜çº§å‡ ä½•çº¦æŸ(åˆ‡çº¿ã€åŒå¿ƒç­‰)

### 14.2 å¯¹æ¯”åˆ†æ

| ç‰¹æ€§ | dist6å®ç° | ä¸“ä¸šCAD (å¦‚SolidWorks) |
|------|----------|----------------------|
| çº¦æŸç±»å‹ | 2ç§(æ–¹ç¨‹+ä½ç½®) | 10+ç§(è·ç¦»/è§’åº¦/åŒå¿ƒ/åˆ‡çº¿ç­‰) |
| æ±‚è§£æ–¹æ³• | å•å‘ä¼ æ’­ | åŒå‘è¿­ä»£ä¼˜åŒ–(LM/Newton) |
| å†²çªå¤„ç† | ç®€å•è¿‡æ»¤ | æ™ºèƒ½æç¤ºå’Œè‡ªåŠ¨ä¿®å¤ |
| æ€§èƒ½ | O(n)å¿«é€Ÿ | O(nÂ²)ä½†æ›´ç²¾ç¡® |
| é€‚ç”¨åœºæ™¯ | BIMæˆ·å‹è®¾è®¡ | ç²¾å¯†æœºæ¢°è®¾è®¡ |

### 14.3 åº”ç”¨åœºæ™¯

**âœ… æœ€é€‚åˆ**:
- å»ºç­‘æˆ·å‹å›¾ç»˜åˆ¶
- å¢™ä½“å¸ƒå±€çº¦æŸ
- å¼€å­”ä½ç½®æ§åˆ¶
- æˆ¿é—´è½®å»“ç¼–è¾‘

**âš ï¸ ä¸é€‚åˆ**:
- å¤æ‚æ›²çº¿çº¦æŸ
- é«˜ç²¾åº¦æœºæ¢°è®¾è®¡
- éœ€è¦åŒå‘æ±‚è§£çš„åœºæ™¯

---

## åäº”ã€æ–‡ä»¶ç´¢å¼•

### 15.1 2Då‡ ä½•æ ¸å¿ƒæ–‡ä»¶

| æ–‡ä»¶ | æ¨¡å—ID | æ ¸å¿ƒç±» | åŠŸèƒ½ |
|------|--------|--------|------|
| curve2d_io.js | 46088 | Curve2d | 2Dæ›²çº¿åŸºç±» |
| line2d_io.js | 43297 | Line2d | 2Dç›´çº¿ |
| arc2d.js | 80534 | Arc2d | 2Dåœ†å¼§ |
| circle2d.js | 99876, 51856 | Circle2d | 2Dåœ† |
| polygon2d.js | 47816 | Polygon2d | 2Då¤šè¾¹å½¢ |
| polycurve2d.js | 99123 | PolyCurve2d | å¤åˆæ›²çº¿ |
| discretepolygon2d.js | 1081 | DiscretePolygon2d | ç¦»æ•£å¤šè¾¹å½¢ |
| continuouscurve2d.js | 24194 | ContinuousCurve2d | è¿ç»­æ›²çº¿ |

### 15.2 çº¦æŸç³»ç»Ÿæ ¸å¿ƒæ–‡ä»¶

| æ–‡ä»¶ | æ¨¡å—ID | æ ¸å¿ƒç±» | åŠŸèƒ½ |
|------|--------|--------|------|
| constraint.js | 48855, 84418 | Constraint | çº¦æŸåŸºç±» |
| module_26429.js | 26429 | EquationConstraint | æ–¹ç¨‹çº¦æŸ |
| positionconstraint.js | 47636 | PositionConstraint | ä½ç½®çº¦æŸ |
| constraintfactory.js | 99857 | ConstraintFactory | çº¦æŸå·¥å‚ |
| constrainthelper.js | 223024 | ConstraintHelper | çº¦æŸè¾…åŠ© |
| constraintutil.js | 96982 | ConstraintUtil | çº¦æŸå·¥å…· |

### 15.3 ç‰¹æ®Šæ›²çº¿æ–‡ä»¶

| æ–‡ä»¶ | æ¨¡å—ID | è¯´æ˜ |
|------|--------|------|
| extraordinarycurve2d.js | 35656 | ç‰¹æ®Šæ›²çº¿åŸºç±» |
| extraordinaryline2d.js | 63905 | ç‰¹æ®Šç›´çº¿ |
| extraordinarycirclearc2d.js | 88143 | ç‰¹æ®Šåœ†å¼§ |
| extraordinarycircle2d.js | 18687 | ç‰¹æ®Šåœ† |
| guideline2d_io.js | 45793 | è¾…åŠ©çº¿ |

---

## åå…­ã€å…³é”®ä»£ç ç»Ÿè®¡

### 16.1 APIä½¿ç”¨é¢‘ç‡

åŸºäº144ä¸ªæœç´¢ç»“æœ:

| API | å‡ºç°æ¬¡æ•° | ä¸»è¦ç”¨é€” |
|-----|---------|---------|
| `MathAlg.Intersect.curve2ds()` | 15+ | æ›²çº¿ç›¸äº¤è®¡ç®— |
| `MathAlg.CalculateOverlap.curve2ds()` | 12+ | æ›²çº¿é‡å æ£€æµ‹ |
| `MathAlg.PositionJudge.loopToLoop()` | 8+ | ç¯ä½ç½®å…³ç³» |
| `MathAlg.BoolOperate2d.union()` | 6+ | 2Då¹¶é›†è¿ç®— |
| `surface.getCurve2d()` | 20+ | 3Dâ†’2DæŠ•å½± |
| `plane.getCurve3d()` | 10+ | 2Dâ†’3Dæå‡ |
| `polygon.getLoops()` | 15+ | è·å–å¤šè¾¹å½¢ç¯ |

### 16.2 çº¦æŸç³»ç»Ÿé›†æˆç»Ÿè®¡

- **ä½¿ç”¨çº¦æŸçš„æ¨¡å‹ç±»**: 20+
- **çŠ¶æ€ç®¡ç†ä½ç½®**: Document, ParametricModel, Pattern, Region
- **çº¦æŸç±»å‹æ³¨å†Œ**: 2ç§æ ¸å¿ƒç±»å‹
- **çº¦æŸå·¥å‚å®ä¾‹**: å•ä¾‹æ¨¡å¼

---

## åä¸ƒã€æœ€ç»ˆç»“è®º

### 17.1 2Då‡ ä½•å†…æ ¸è¯„ä»·

**å®ç°ç±»å‹**: **è‡ªå®šä¹‰ä¸ºä¸» (90%) + GeLibè¾…åŠ© (10%)**

**æ ¸å¿ƒç»„ä»¶**:
1. âœ… **å®Œæ•´çš„2Då‡ ä½•å›¾å…ƒä½“ç³»** (Curve2d/Arc2d/Line2d/Circle2d/Polygon2d)
2. âœ… **å‚æ•°åŒ–çº¦æŸç³»ç»Ÿ** (EquationConstraint/PositionConstraint)
3. âœ… **ä¸°å¯Œçš„å‡ ä½•ç®—æ³•** (ç›¸äº¤/é‡å /å¸ƒå°”/ä½ç½®åˆ¤æ–­)
4. âœ… **2D-3DåŒå‘è½¬æ¢** (æŠ•å½±/æå‡æœºåˆ¶)

**æŠ€æœ¯äº®ç‚¹**:
- ğŸŒŸ Esprimaé›†æˆå®ç°è¡¨è¾¾å¼çº¦æŸ
- ğŸŒŸ æ‹“æ‰‘æ’åºè‡ªåŠ¨å¤„ç†çº¦æŸä¾èµ–
- ğŸŒŸ å°„çº¿æ³•é«˜æ•ˆç‚¹åœ¨å¤šè¾¹å½¢å†…åˆ¤æ–­
- ğŸŒŸ Entityç»§æ‰¿ä½“ç³»ç»Ÿä¸€ç®¡ç†

**åº”ç”¨ä»·å€¼**:
- é€‚åˆBIM/å»ºç­‘è®¾è®¡é¢†åŸŸ
- æ”¯æŒå¿«é€Ÿæˆ·å‹è‰å›¾ç»˜åˆ¶
- å‚æ•°åŒ–é©±åŠ¨çš„è®¾è®¡ä¿®æ”¹
- ä¸3D BREPååŒå·¥ä½œ

### 17.2 ä¸3Då†…æ ¸å¯¹æ¯”

| ç»´åº¦ | 2Då†…æ ¸ | 

3Då†…æ ¸ | è‡ªå®šä¹‰ç¨‹åº¦ |
|------|---------|---------|------------|
| **æ ¸å¿ƒå®ç°** | è‡ªå®šä¹‰ (90%) | è‡ªå®šä¹‰ (70%) | 2Dæ›´è‡ªä¸» |
| **æ•°æ®ç»“æ„** | Curve2d/Polygon2d | Face/Edge/Vertex/Loop | éƒ½å®Œæ•´ |
| **å‚æ•°åŒ–** | âœ… çº¦æŸæ±‚è§£ | âŒ æ— å‚æ•°åŒ– | 2Dä¼˜åŠ¿ |
| **ç²¾åº¦æ§åˆ¶** | è§£æå‡ ä½• | è§£æå‡ ä½• | ç›¸åŒ |
| **ç¬¬ä¸‰æ–¹ä¾èµ–** | GeLibè¾…åŠ© | WebCADModelAPIä¸»åŠ› | 2Dæ›´ç‹¬ç«‹ |
| **åº”ç”¨åœºæ™¯** | è‰å›¾/è½®å»“ç¼–è¾‘ | å®ä½“å»ºæ¨¡/æ¸²æŸ“ | äº’è¡¥ |

### 17.3 ååŒå·¥ä½œæ¨¡å¼

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”¨æˆ·æ“ä½œ    â”‚
â”‚  (ç»˜åˆ¶å¢™ä½“)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2Dçº¦æŸæ±‚è§£          â”‚
â”‚  - é•¿åº¦çº¦æŸ          â”‚
â”‚  - å¹³è¡Œçº¦æŸ          â”‚
â”‚  - å¯¹é½çº¦æŸ          â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2Då‡ ä½•ç”Ÿæˆ          â”‚
â”‚  - Line2d            â”‚
â”‚  - Arc2d             â”‚
â”‚  - Polygon2d         â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼ getCurve3d()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3Dæ›²çº¿              â”‚
â”‚  - Line3d            â”‚
â”‚  - Arc3d             â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼ extrudePath()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3D BREP             â”‚
â”‚  - Face              â”‚
â”‚  - Edge              â”‚
â”‚  - Vertex            â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼ getCurve2d()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2Dç¼–è¾‘ (æŠ•å½±å›UV)   â”‚
â”‚  - å¼€å­”ç¼–è¾‘          â”‚
â”‚  - é¢æè´¨æ˜ å°„        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## åå…«ã€å‚è€ƒä»£ç ç‰‡æ®µ

### 18.1 å®Œæ•´çš„çº¦æŸç³»ç»Ÿç¤ºä¾‹

```javascript
// åˆ›å»ºå‚æ•°åŒ–é—¨æ¨¡å‹
class ParametricDoor {
    constructor() {
        this.states = {
            // ä½ç½®
            x: new State("x", 0),
            y: new State("y", 0),
            
            // å°ºå¯¸
            width: new State("width", 900),
            height: new State("height", 2100),
            thickness: new State("thickness", 50),
            
            // è®¡ç®—å€¼
            x2: new State("x2", 0),
            y2: new State("y2", 0),
            area: new State("area", 0)
        };
        
        this.constraints = {};
        
        // æ·»åŠ çº¦æŸ
        this.addConstraints();
    }
    
    addConstraints(): void {
        // çº¦æŸ1: å³ä¾§X = å·¦ä¾§X + å®½åº¦
        const c1 = new EquationConstraint();
        c1.equation = "x2 = x + width";
        c1.inputs = {
            x: this.states.x,
            width: this.states.width
        };
        c1.outputs = {x2: this.states.x2};
        this.constraints[c1.localId] = c1;
        
        // çº¦æŸ2: é¡¶éƒ¨Y = åº•éƒ¨Y + é«˜åº¦
        const c2 = new EquationConstraint();
        c2.equation = "y2 = y + height";
        c2.inputs = {
            y: this.states.y,
            height: this.states.height
        };
        c2.outputs = {y2: this.states.y2};
        this.constraints[c2.localId] = c2;
        
        // çº¦æŸ3: é¢ç§¯ = å®½åº¦ Ã— é«˜åº¦
        const c3 = new EquationConstraint();
        c3.equation = "area = width * height";
        c3.inputs = {
            width: this.states.width,
            height: this.states.height
        };
        c3.outputs = {area: this.states.area};
        this.constraints[c3.localId] = c3;
    }
    
    // æ±‚è§£çº¦æŸ
    solve(): void {
        Object.values(this.constraints).forEach(c => {
            c.compute();
        });
    }
    
    // ç”Ÿæˆ2Dè½®å»“
    generate2DProfile(): Polygon2d {
        // å…ˆæ±‚è§£çº¦æŸ
        this.solve();
        
        // åˆ›å»ºçŸ©å½¢è½®å»“
        const points = [
            {x: this.states.x.value, y: this.states.y.value},
            {x: this.states.x2.value, y: this.states.y.value},
            {x: this.states.x2.value, y: this.states.y2.value},
            {x: this.states.x.value, y: this.states.y2.value}
        ];
        
        const polygon = new Polygon2d();
        polygon.outer.setFromPoints(points);
        
        return polygon;
    }
    
    // ç”Ÿæˆ3Dæ¨¡å‹
    generate3DModel(): BrepBody {
        const profile2d = this.generate2DProfile();
        
        // æå‡åˆ°3D
        const curves3d = profile2d.outer.curves.map(curve2d =>
            Plane.XOY().getCurve3d(curve2d)
        );
        
        // æ‹‰ä¼¸
        const brep = WebCADModelAPI.extrudePath(
            curves3d,
            this.states.thickness.value
        );
        
        return brep;
    }
    
    // ä¿®æ”¹å‚æ•°
    setWidth(newWidth: number): void {
        this.states.width.value = newWidth;
        this.solve();  // è‡ªåŠ¨æ›´æ–°x2å’Œarea
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const door = new ParametricDoor();
console.log(door.states.area.value);  // 1890000 (900 * 2100)

door.setWidth(1000);
console.log(door.states.x2.value);    // 1000
console.log(door.states.area.value);  // 2100000 (1000 * 2100)

const brep = door.generate3DModel();
```

---

## åä¹ã€æ€»ç»“

### 19.1 2Då‡ ä½•å†…æ ¸æ ¸å¿ƒä»·å€¼

1. **å‚æ•°åŒ–è®¾è®¡èƒ½åŠ›**: é€šè¿‡çº¦æŸç³»ç»Ÿå®ç°å‚æ•°é©±åŠ¨
2. **ç²¾ç¡®å‡ ä½•è¡¨ç¤º**: ä¿ç•™è§£æå½¢å¼,é¿å…ç¦»æ•£åŒ–è¯¯å·®
3. **é«˜æ•ˆç®—æ³•åº“**: è‡ªä¸»å®ç°æ ¸å¿ƒå‡ ä½•ç®—æ³•
4. **ä¸3DååŒ**: æ— ç¼çš„2D-3Dè½¬æ¢æœºåˆ¶

### 19.2 æŠ€æœ¯æ ˆ

```
2Då‡ ä½•å†…æ ¸æŠ€æœ¯æ ˆ:
â”œâ”€â”€ è¯­è¨€: JavaScript/TypeScript
â”œâ”€â”€ è§£æå™¨: Esprima (è¡¨è¾¾å¼çº¦æŸ)
â”œâ”€â”€ å‡ ä½•åº“: è‡ªå®šä¹‰ + GeLibè¾…åŠ©
â”œâ”€â”€ æ•°å­¦åº“: è‡ªå®šä¹‰MathAlg
â””â”€â”€ æ¸²æŸ“: THREE.js (å¯é€‰é›†æˆ)
```

### 19.3 é€‚ç”¨åœºæ™¯

**âœ… æ¨èç”¨äº**:
- BIMå»ºç­‘è®¾è®¡
- æˆ·å‹å›¾ç»˜åˆ¶
- å®¤å†…è®¾è®¡
- å‚æ•°åŒ–å®¶å…·è®¾è®¡

**âš ï¸ ä¸æ¨èç”¨äº**:
- ç²¾å¯†æœºæ¢°CAD
- å¤æ‚æ›²é¢è®¾è®¡
- éœ€è¦é«˜çº§çº¦æŸçš„åœºæ™¯

---

## é™„å½•: å…³é”®ç±»å‹å®šä¹‰

```typescript
// 2Då‡ ä½•ç±»å‹
interface Point2d {
    x: number;
    y: number;
}

interface IArc2d {
    start: Point2d;
    end: Point2d;
    center: Point2d;
    radius: number;
    clockwise: boolean;
}

interface IPolygon2d {
    outer: PolyCurve2d;
    holes: PolyCurve2d[];
}

// çº¦æŸç±»å‹
interface IConstraintData {
    localId: string;
    type: string;
    inputs: State[];
    outputs: State[];
    equation?: string;            // EquationConstraint
    computeChain?: ComputeChain[]; // PositionConstraint
}

interface ComputeChain {
    method: 'add' | 'sub' | 'mul' | 'div' | 
            'result_add' | 'result_sub' | 
            'result_mul' | 'result_div' | 
            'nonnegative';
    states: State[];
}

// å‡ ä½•ç®—æ³•è¿”å›ç±»å‹
interface Intersection {
    point: Point2d;
    param1: number;  // åœ¨curve1ä¸Šçš„å‚æ•°
    param2: number;  // åœ¨curve2ä¸Šçš„å‚æ•°
}

interface Overlap {
    isSameDirection: boolean;
    range1: {min: number, max: number};
    range2: {min: number, max: number};
}

enum LoopLoopPositonType {
    OUT,      // å¤–éƒ¨
    IN,       // å†…éƒ¨
    OVERLAP   // é‡å 
}

enum PtLoopPositonType {
    ONEDGE,   // åœ¨è¾¹ä¸Š
    ONVERTEX, // åœ¨é¡¶ç‚¹ä¸Š
    INSIDE,   // å†…éƒ¨
    OUTSIDE   // å¤–éƒ¨
}
```

---

**æ–‡æ¡£å®Œæˆæ—¶é—´**: 2026-01-23  
**åˆ†ææ–‡ä»¶æ•°**: 144ä¸ª2Då‡ ä½•ç›¸å…³æ–‡ä»¶  
**ä»£ç ç¤ºä¾‹**: 15+ä¸ªå®é™…åº”ç”¨åœºæ™¯  
**æ¶æ„å›¾è¡¨**: 8ä¸ª
